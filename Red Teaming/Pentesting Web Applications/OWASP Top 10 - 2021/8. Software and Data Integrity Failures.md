### What is Integrity?  

<mark style="background: #BBFABBA6;">When talking about integrity, we refer to the capacity we have to ascertain that a piece of data remains unmodified</mark>. Integrity is essential in cybersecurity as we care about maintaining important data free from unwanted or malicious modifications. For example, say we're downloading the latest installer for an application. How can we be sure that while downloading it, it wasn't modified in transit or somehow got damaged by a transmission error?

<mark style="background: #BBFABBA6;">To overcome this problem, we'll often see a **hash** sent alongside the file so that we can prove that the file we downloaded kept its integrity and wasn't modified in transit</mark>. A hash or digest is simply a number that results from applying a specific algorithm over a piece of data. When reading about hashing algorithms, we'll often read about MD5, SHA1, SHA256 or many others available.

Let's take WinSCP as an example to understand better how we can use hashes to check a file's integrity. If we go to their [Sourceforge repository](https://sourceforge.net/projects/winscp/files/WinSCP/5.21.5/), we'll see that for each file available to download, there are some hashes published along:

![WinSCP hashes](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/b93dd140259193ee75ae1d12562bbd29.png)  

These hashes were precalculated by the creators of WinSCP so that we can check the file's integrity after downloading. If we download the `WinSCP-5.21.5-Setup.exe` file, we can recalculate the hashes and compare them against the ones published in Sourceforge. To calculate the different hashes in Linux, we can use the following commands:

AttackBox:

```shell-session
user@attackbox$ md5sum WinSCP-5.21.5-Setup.exe          
20c5329d7fde522338f037a7fe8a84eb  WinSCP-5.21.5-Setup.exe
                                                                                                                
user@attackbox$ sha1sum WinSCP-5.21.5-Setup.exe 
c55a60799cfa24c1aeffcd2ca609776722e84f1b  WinSCP-5.21.5-Setup.exe
                                                                                                                
user@attackbox$ sha256sum WinSCP-5.21.5-Setup.exe 
e141e9a1a0094095d5e26077311418a01dac429e68d3ff07a734385eb0172bea  WinSCP-5.21.5-Setup.exe
```

Since we got the same hashes, we can safely conclude that the file we downloaded is an exact copy of the one on the website.

<mark style="background: #FF5582A6;">Software and Data Integrity Failures  </mark>

This vulnerability arises from code or infrastructure that uses software or data without using any kind of integrity checks. Since no integrity verification is being done, an attacker might modify the software or data passed to the application, resulting in unexpected consequences. There are mainly two types of vulnerabilities in this category:

- Software Integrity Failures
- Data Integrity Failures

### Software Integrity Failures

Suppose we have a website that uses third-party libraries that are stored in some external servers that are out of our control. While this may sound a bit strange, this is actually a somewhat common practice. Take as an example jQuery, a commonly used javascript library. If we want, we can include jQuery in our website directly from their servers without actually downloading it by including the following line in the HTML code of our website:

```html
<script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
```

When a user navigates to our website, its browser will read its HTML code and download jQuery from the specified external source.

![JS without integrity checks](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/95712e9b375e22a57613a75c6b81384d.png)  

The problem is that if an attacker somehow hacks into the jQuery official repository, they could change the contents of `https://code.jquery.com/jquery-3.6.1.min.js` to inject malicious code. As a result, anyone visiting our website would now pull the malicious code and execute it into their browsers unknowingly. <mark style="background: #FF5582A6;">This is a software integrity failure</mark> as our website makes no checks against the third-party library to see if it has changed. Modern browsers allow us to specify a hash along the library's URL so that the library code is executed only if the hash of the downloaded file matches the expected value. This security mechanism is called <mark style="background: #BBFABBA6;">Subresource Integrity (SRI)</mark>, and we can read more about it [here](https://www.srihash.org/).

The correct way to insert the library in our HTML code would be to use SRI and include an integrity hash so that if somehow an attacker is able to modify the library, any client navigating through our website won't execute the modified version. Here's how that should look in HTML:

```html
<script src="https://code.jquery.com/jquery-3.6.1.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>
```

We can go to [https://www.srihash.org/](https://www.srihash.org/) to generate hashes for any library if needed.

### Data Integrity Failures

Let's think of how web applications maintain sessions. Usually, when a user logs into an application, they will be assigned some sort of session token that will need to be saved on the browser for as long as the session lasts. This token will be repeated on each subsequent request so that the web application knows who we are. These session tokens can come in many forms but are usually assigned via cookies. **Cookies** are key-value pairs that a web application will store on the user's browser and that will be automatically repeated on each request to the website that issued them.  

![Cookies](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/9c9ed045f84136a6e0100f4111d7f34d.png)  

For example, if we were creating a webmail application, we could assign a cookie to each user after logging in that contains their username. In subsequent requests, our browser would always send our username in the cookie so that our web application knows what user is connecting. This would be a terrible idea security-wise because, as we mentioned, cookies are stored on the user's browser, so if the user tampers with the cookie and changes the username, they could potentially impersonate someone else and read their emails! This application would suffer from a data integrity failure, as it trusts data that an attacker can tamper with.

One solution to this is to use some integrity mechanism to guarantee that the cookie hasn't been altered by the user. To avoid re-inventing the wheel, we could use some token implementations that allow us to do this and deal with all of the cryptography to provide proof of integrity without we having to bother with it. One such implementation is **<mark style="background: #BBFABBA6;">JSON Web Tokens (JWT)</mark>**.

JWTs are very simple tokens that allow us to store key-value pairs on a token that provides integrity as part of the token. The idea is that we can generate tokens that we can give our users with the certainty that they won't be able to alter the key-value pairs and pass the integrity check. The structure of a JWT token is formed of 3 parts:

![JSON Web Tokens](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/11c86acaea05f98045cec5634e03e997.png)

The header contains metadata indicating this is a JWT, and the signing algorithm in use is HS256. The payload contains the key-value pairs with the data that the web application wants the client to store. The signature is similar to a hash, taken to verify the payload's integrity. If we change the payload, the web application can verify that the signature won't match the payload and know that our tampered with the JWT. Unlike a simple hash, this signature involves the use of a secret key held by the server only, which means that if we change the payload, we won't be able to generate the matching signature unless we know the secret key.

Notice that each of the 3 parts of the token is simply plaintext encoded with base64. We can use [this online tool](https://appdevtools.com/base64-encoder-decoder) to encode/decode base64.

### JWT and the None Algorithm

A data integrity failure vulnerability was present on some libraries implementing JWTs a while ago. As we have seen, JWT implements a signature to validate the integrity of the payload data. The vulnerable libraries allowed attackers to bypass the signature validation by changing the two following things in a JWT:

<mark style="background: #FF5582A6;">1. Modify the header section of the token so that the `alg` header would contain the value `none`</mark>.
<mark style="background: #FF5582A6;">2. Remove the signature part</mark>.

Taking the JWT from before as an example, if we wanted to change the payload so that the username becomes "admin" and no signature check is done, we would have to decode the header and payload, modify them as needed, and encode them back. Notice how we removed the signature part but kept the dot at the end.

![JWT None Algorithm](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/f5d1b4ef49ff4eef52e7617631225e8a.png)  